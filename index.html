<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Sky Flap — A Flappy Bird–style HTML5 Game</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<style>
  html, body {
    margin:0; padding:0; height:100%; background:#0a0e18; color:#eee; overflow:hidden;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }
  #game { display:block; width:100vw; height:100vh; background:#0d1222; }
  .overlay {
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none;
  }
  .btn {
    display:inline-block; padding:.7rem 1.1rem; margin:.35rem .25rem; border-radius:12px;
    background:#18a0fb; color:#fff; font-weight:700; letter-spacing:.3px; box-shadow:0 6px 24px rgba(0,0,0,.25);
    transition:transform .08s ease, filter .12s ease; pointer-events:auto; user-select:none; cursor:pointer;
  }
  .btn:active { transform:translateY(1px) scale(.98); filter:brightness(.95); }
  .muter {
    position:fixed; right:.75rem; top:.75rem; z-index:10; pointer-events:auto;
    background:rgba(0,0,0,.35); border-radius:12px; padding:.35rem .55rem; font-size:.9rem;
  }
  .hud {
    position:fixed; left:0; right:0; top:0; display:flex; justify-content:center; align-items:flex-start;
    padding-top:14px; pointer-events:none; font-weight:800; text-shadow:0 2px 0 rgba(0,0,0,.5);
  }
  .score {
    font-size:52px; line-height:1; letter-spacing:1px; background:linear-gradient(#fff,#dfe9ff);
    -webkit-background-clip:text; background-clip:text; color:transparent;
  }
  .subhud {
    position:fixed; left:12px; top:12px; font-size:12px; opacity:.85; pointer-events:none;
  }
  .toast {
    position:fixed; left:50%; transform:translateX(-50%); bottom:18px; font-size:12px; opacity:.85;
    background:rgba(0,0,0,.35); padding:.35rem .6rem; border-radius:10px; pointer-events:none;
  }
  .fade { animation:fade .45s ease both; }
  @keyframes fade { from{opacity:0} to{opacity:1} }
  .panel {
    background:rgba(8,12,24,.82);
    border:1px solid rgba(255,255,255,.07);
    border-radius:16px; padding:18px 20px; backdrop-filter: blur(6px);
    box-shadow:0 20px 50px rgba(0,0,0,.45); color:#e7eeff;
  }
  .title { font-size:38px; font-weight:900; letter-spacing:.5px; margin:0 0 10px 0; }
  .small { font-size:12px; opacity:.8 }
  .row { display:flex; justify-content:center; flex-wrap:wrap; margin-top:8px; }
  .key { display:inline-block; min-width:22px; text-align:center; padding:.2rem .45rem; border-radius:8px;
         border:1px solid rgba(255,255,255,.15); background:rgba(255,255,255,.06); margin:0 .2rem; }
  /* Accessibility focus (keyboard) */
  .btn:focus, .muter:focus { outline:2px solid #8ad; outline-offset:2px; }
</style>

<!--
README
=====
Sky Flap is a fully standalone, offline HTML5 Canvas game.

Run:
- Save this file as index.html and open it in Chrome/Edge/Firefox (no server required).

Controls:
- Space / Arrow Up / Mouse click / Touch = Flap
- P = Pause/Unpause
- M = Mute/Unmute

Tuning:
- All key parameters live in CONFIG (search "CONFIG — Tunable parameters").
- Adjust values, reload the page.
- High score is stored in localStorage under "skyflap.highscore.v1".

Performance:
- Uses requestAnimationFrame, object pooling, minimal per-frame allocations.
- FPS watchdog gracefully reduces particles/shadows when < 50 FPS.

Self-tests:
- Open DevTools console and call: SELFTEST.runAll() to execute quick physics & generator checks.

-->

</head>
<body>
<canvas id="game" width="1280" height="720" aria-label="Sky Flap game canvas"></canvas>

<div class="hud">
  <div id="score" class="score">0</div>
</div>
<div class="subhud" id="subhud">Best: 0</div>
<div class="overlay" id="overlay"></div>
<div class="muter btn" id="muteBtn" role="button" aria-label="Toggle sound">🔊</div>
<div class="toast" id="toast" style="display:none;"></div>

<script type="module">
/* ===========================================================
   Sky Flap — Professional Flappy Bird–style HTML5 Canvas Game
   Author: You (Game Developer)
   Offline, single-file, no external assets or libraries.
   =========================================================== */

/* ===============================
   CONFIG — Tunable parameters
   Ranges & defaults chosen from testing; see tuning table below.
   =============================== */
const CONFIG = {
  // Canvas & world
  width: 1280, height: 720, deviceScaleCap: 1.5,

  // Physics (world units ~ pixels)
  gravity: 1900,           // [1200..3200] px/s^2 — Downwards acceleration
  flapForce: 600,          // [420..700] px/s instantaneous upward impulse (added to -vy)
  terminalVelocity: 780,   // [680..1000] px/s max downward speed
  maxRotation: 52,         // [35..65] deg — visual tilt cap
  rotationSpeed: 520,      // [360..720] deg/s — how fast we ease toward target tilt
  dragUp: 0.065,            // [0.04..0.08] — damp upward overshoot
  dragDown: 0.02,         // [0.01..0.025] — small steady drag

  // Pipes / difficulty
  pipeSpeed: 240,          // [200..400] px/s base scroll speed
  spawnInterval: 1.4,      // [1.1..1.8] s between pipe pairs
  initialGap: 210,         // [180..260] px
  minGap: 150,             // never go below
  gapDecreaseEvery: 5,     // every N points, shrink gap & speed up slightly
  gapDecreaseStep: 10,     // px decrease per difficulty step
  speedIncreaseStep: 12,   // px/s increase per difficulty step
  speedCap: 380,           // px/s maximum pipe speed
  pipeWidth: 106,          // visual pipe width
  pipeLip: 16,             // top/bottom lip height
  safeMargin: 74,          // keep gaps within [safeMargin .. h-safeMargin]

  // Generator feasibility guard
  maxGapDeltaPerPipe: 180, // limit vertical shift between consecutive gaps

  // Bird
  birdX: 34 + 180,         // starting X position
  birdRadius: 22,          // collision circle radius for refinement
  birdAABBPad: 2,          // shrink AABB slightly to feel fair

  // Scoring
  scorePopScale: 1.25,     // hit scale when score increases
  scorePopTime: 160,       // ms

  // Effects
  enableParticles: true,
  enableShadows: true,
  particlePool: 140,
  flapTrailCount: 8,

  // FPS guard
  fpsDropDisableEffectsBelow: 50,

  // Audio (synth)
  volume: 0.7,             // [0..1]
  bgmVolume: 0.28,
  sfx: {
    flap: { type:'square', freq:480, dur:0.075, attack:0.002, decay:0.07 },
    score:{ type:'sine',   freq:820, dur:0.09,  attack:0.001, decay:0.085 },
    hit:  { type:'triangle', freq:120, dur:0.22, attack:0.001, decay:0.21 }
  },

  // UI transitions
  fadeTime: 350,           // ms
};

/* ===============================
   GLOBALS & INITIALIZATION
   =============================== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha:false, desynchronized:true });
const overlay = document.getElementById('overlay');
const scoreEl = document.getElementById('score');
const subhudEl = document.getElementById('subhud');
const toastEl = document.getElementById('toast');
const muteBtn = document.getElementById('muteBtn');

const LS_KEY = 'skyflap.highscore.v1';
let highScore = +localStorage.getItem(LS_KEY) || 0;

// Device pixel ratio handling (cap for perf stability)
const DPR = Math.min(window.devicePixelRatio || 1, CONFIG.deviceScaleCap);
function resize() {
  const w = Math.min(window.innerWidth, CONFIG.width);
  const h = Math.min(window.innerHeight, CONFIG.height);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = Math.round(w * DPR);
  canvas.height = Math.round(h * DPR);
  view.w = w; view.h = h;
}
window.addEventListener('resize', resize);

// Viewport logical size (independent of DPR for gameplay)
const view = { w: CONFIG.width, h: CONFIG.height };
resize();

/* ===============================
   AUDIO — Procedural WebAudio SFX
   =============================== */
const Audio = (() => {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  let muted = false;
  let bgmNode = null;
  function beep({type='sine', freq=440, dur=0.1, attack=0.005, decay=0.095}, vol=CONFIG.volume) {
    if (muted) return;
    const now = ctx.currentTime;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, now);
    g.gain.setValueAtTime(0, now);
    g.gain.linearRampToValueAtTime(vol, now + attack);
    g.gain.exponentialRampToValueAtTime(0.0001, now + attack + decay);
    o.connect(g).connect(ctx.destination);
    o.start(now);
    o.stop(now + dur);
  }
  function toggleMute(flag) {
    muted = (flag !== undefined) ? !!flag : !muted;
    muteBtn.textContent = muted ? '🔇' : '🔊';
    return muted;
  }
  // Simple gentle background pad (optional, off by default; toggle via M)
  function playBgm(on=true) {
    if (!on || bgmNode || muted) return;
    const n = ctx.createOscillator();
    const g = ctx.createGain();
    n.type = 'sine';
    n.frequency.value = 220;
    g.gain.value = CONFIG.bgmVolume;
    n.connect(g).connect(ctx.destination);
    n.start();
    bgmNode = { n, g };
  }
  function stopBgm() {
    if (bgmNode) {
      try { bgmNode.n.stop(); } catch(e){}
      bgmNode = null;
    }
  }
  return { ctx, beep, toggleMute, playBgm, stopBgm, get muted(){return muted;} };
})();

/* ===============================
   INPUT — keyboard/mouse/touch
   Debounced < 50ms via immediate queueing.
   =============================== */
const Input = (() => {
  let flapQueued = false;
  let pausedToggleQueued = false;
  let lastEventTs = 0;

  function queueFlap(e) {
    // consume quickly; we allow multiple per frame if distinct events
    const now = performance.now();
    if (now - lastEventTs > 8) { // ultra-light debounce (<<50ms)
      flapQueued = true;
      lastEventTs = now;
    }
    e && e.preventDefault && e.preventDefault();
  }
  function queuePause(e) { pausedToggleQueued = true; e && e.preventDefault && e.preventDefault(); }

  window.addEventListener('keydown', e => {
    if (e.code === 'Space' || e.code === 'ArrowUp') queueFlap(e);
    else if (e.code === 'KeyP') queuePause(e);
    else if (e.code === 'KeyM') Audio.toggleMute();
  });
  window.addEventListener('mousedown', queueFlap, {passive:false});
  window.addEventListener('touchstart', queueFlap, {passive:false});

  return {
    consumeFlap(){ const v = flapQueued; flapQueued = false; return v; },
    consumePause(){ const v = pausedToggleQueued; pausedToggleQueued = false; return v; },
  };
})();

/* ===============================
   UTIL
   =============================== */
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const lerp = (a,b,t)=>a+(b-a)*t;
const easeOut = t => 1 - Math.pow(1-t, 2.2);
const rand = (a,b)=>a+Math.random()*(b-a);
const nowMS = ()=>performance.now();

/* ===============================
   GAME STATE
   =============================== */
const State = {
  mode: 'title', // 'title'|'play'|'paused'|'gameover'
  score: 0,
  best: highScore,
  time: 0,
  difficultySteps: 0,
  scroll: CONFIG.pipeSpeed,
  gap: CONFIG.initialGap,
  lastSpawn: 0,
  fps: 60,
  effectsReduced: false,
};

/* ===============================
   OBJECT POOLS
   =============================== */
class Pool {
  constructor(klass, size) {
    this.klass = klass; this.pool = new Array(size);
    for (let i=0;i<size;i++) this.pool[i] = new klass();
  }
  get() {
    for (let i=0;i<this.pool.length;i++) {
      const o = this.pool[i];
      if (!o.active) { o.active = true; return o; }
    }
    // Expand cautiously if needed
    const o = new this.klass(); o.active = true; this.pool.push(o); return o;
  }
  forEachActive(fn) {
    for (let i=0;i<this.pool.length;i++) {
      const o = this.pool[i]; if (o.active) fn(o);
    }
  }
}
class Particle {
  constructor(){ this.active=false; }
  init(x,y,vx,vy,life,sz,col,grav=0) {
    this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.life=life; this.t=0; this.sz=sz; this.col=col; this.g=grav; this.active=true;
  }
  step(dt) {
    this.t += dt; if (this.t>=this.life) { this.active=false; return; }
    this.vy += this.g*dt;
    this.x += this.vx*dt; this.y += this.vy*dt;
  }
  draw(ctx) {
    const a = 1 - this.t/this.life;
    ctx.globalAlpha = a;
    ctx.fillStyle = this.col;
    ctx.beginPath(); ctx.arc(this.x, this.y, this.sz*(0.7+0.3*a), 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
  }
}
const particles = new Pool(Particle, CONFIG.particlePool);

/* ===============================
   BIRD
   =============================== */
const Bird = {
  x: CONFIG.birdX, y: view.h*0.5, vx: 0, vy: 0,
  rot: 0, targetRot: 0,
  frame: 0, frameTime: 0,
  alive: true,
  reset() {
    this.x = CONFIG.birdX; this.y = view.h*0.5; this.vx = 0; this.vy = 0;
    this.rot = 0; this.targetRot = 0; this.alive = true;
  },
  flap() {
    this.vy = -CONFIG.flapForce;
    if (CONFIG.enableParticles && !State.effectsReduced) {
      for (let i=0;i<CONFIG.flapTrailCount;i++){
        const a = rand(-Math.PI,Math.PI), sp= rand(40,120);
        particles.get().init(this.x-18, this.y+12, Math.cos(a)*sp-60, Math.sin(a)*sp+30, rand(.22,.42), rand(1.2,2.2), 'rgba(255,255,255,.85)', 240);
      }
    }
    Audio.beep(CONFIG.sfx.flap);
  },
  step(dt) {
    // Gravity & drag
    this.vy += CONFIG.gravity*dt;
    if (this.vy < 0) this.vy += -this.vy*CONFIG.dragUp*dt*60;
    else this.vy += CONFIG.dragDown*dt*60;
    this.vy = clamp(this.vy, -CONFIG.flapForce*1.4, CONFIG.terminalVelocity);
    this.y += this.vy*dt;

    // Rotate toward target
    const target = clamp((this.vy/CONFIG.terminalVelocity)*CONFIG.maxRotation, -CONFIG.maxRotation*0.7, CONFIG.maxRotation);
    this.targetRot = target;
    const rotDiff = this.targetRot - this.rot;
    const stepDeg = Math.sign(rotDiff) * CONFIG.rotationSpeed * dt;
    this.rot = Math.abs(stepDeg) > Math.abs(rotDiff) ? this.targetRot : this.rot + stepDeg;

    // Anim frames (3-frame wing flap)
    this.frameTime += dt;
    if (this.frameTime>0.08){ this.frame=(this.frame+1)%3; this.frameTime=0; }
  },
  draw(ctx) {
    ctx.save();
    ctx.translate(this.x*DPR, this.y*DPR);
    ctx.rotate(this.rot*Math.PI/180);
    const s = DPR;

    // Shadow
    if (CONFIG.enableShadows && !State.effectsReduced) {
      ctx.save();
      ctx.globalAlpha = .25;
      ctx.fillStyle = '#000';
      ctx.beginPath(); ctx.ellipse(-4*s, 24*s, 24*s, 8*s, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    // Body (vector sprite)
    const bodyCol = ctx.createLinearGradient(-18*s,-18*s, 20*s, 22*s);
    bodyCol.addColorStop(0,'#ffd66b'); bodyCol.addColorStop(1,'#ff9a3c');
    ctx.fillStyle = bodyCol;
    ctx.strokeStyle = '#572b00'; ctx.lineWidth = 2.2*s;

    // Body circle
    ctx.beginPath(); ctx.ellipse(0,0, 22*s,18*s, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();

    // Belly
    ctx.fillStyle='#fff';
    ctx.beginPath(); ctx.ellipse(2*s,6*s, 14*s,10*s, 0, 0, Math.PI*2); ctx.fill();

    // Eye
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(8*s,-6*s, 6*s, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(10*s,-6*s, 3.2*s, 0, Math.PI*2); ctx.fill();

    // Beak
    ctx.fillStyle='#ffbf3a'; ctx.strokeStyle='#6b3b00';
    ctx.beginPath();
    ctx.moveTo(18*s,-2*s); ctx.lineTo(34*s, -1*s); ctx.lineTo(18*s, 6*s); ctx.closePath();
    ctx.fill(); ctx.stroke();

    // Wing (3 poses)
    ctx.fillStyle='#ffc35a'; ctx.strokeStyle='#5b3200';
    ctx.save();
    let wingRot=0, wy=0;
    if (this.frame===0){ wingRot=-0.6; wy=-10*s; }
    if (this.frame===1){ wingRot=0.2; wy=-2*s; }
    if (this.frame===2){ wingRot=0.8; wy=6*s; }
    ctx.translate(-6*s, wy);
    ctx.rotate(wingRot);
    ctx.beginPath();
    ctx.ellipse(0,0, 12*s,8*s, 0, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();
    ctx.restore();

    ctx.restore();
  },
  aabb(){
    const pad=CONFIG.birdAABBPad;
    return { x:this.x-22+pad, y:this.y-18+pad, w:44-2*pad, h:36-2*pad };
  }
};

/* ===============================
   PIPES
   =============================== */
class PipePair {
  constructor(){ this.active=false; }
  init(x, gapY, gapSize, speed) {
    this.x=x; this.gapY=gapY; this.gap=gapSize; this.speed=speed;
    this.passed=false; this.active=true;
  }
  step(dt){ this.x -= this.speed*dt; if (this.x+CONFIG.pipeWidth<-40){ this.active=false; } }
  draw(ctx) {
    const x = Math.round(this.x)*DPR;
    const w = CONFIG.pipeWidth*DPR;
    const gapTop = Math.round(this.gapY - this.gap/2)*DPR;
    const gapBot = Math.round(this.gapY + this.gap/2)*DPR;

    // Pipe gradient
    const grad = ctx.createLinearGradient(0,0, w,0);
    grad.addColorStop(0,'#6ad66a'); grad.addColorStop(1,'#3aa53a');
    ctx.fillStyle = grad;
    ctx.strokeStyle = '#225d22'; ctx.lineWidth = 2*DPR;

    // Top pipe
    if (gapTop>0) {
      ctx.fillRect(x, 0, w, gapTop - CONFIG.pipeLip*DPR);
      // Lip
      ctx.fillStyle = '#79e079';
      ctx.fillRect(x-2*DPR, gapTop - CONFIG.pipeLip*DPR, w+4*DPR, CONFIG.pipeLip*DPR);
      ctx.strokeRect(x-2*DPR, gapTop - CONFIG.pipeLip*DPR, w+4*DPR, CONFIG.pipeLip*DPR);
      ctx.fillStyle = grad;
    }
    // Bottom pipe
    if (gapBot < view.h) {
      ctx.fillRect(x, gapBot + CONFIG.pipeLip*DPR, w, (view.h*DPR) - (gapBot + CONFIG.pipeLip*DPR));
      // Lip
      ctx.fillStyle = '#79e079';
      ctx.fillRect(x-2*DPR, gapBot, w+4*DPR, CONFIG.pipeLip*DPR);
      ctx.strokeRect(x-2*DPR, gapBot, w+4*DPR, CONFIG.pipeLip*DPR);
    }

    // Subtle lines
    ctx.strokeStyle = 'rgba(0,0,0,.18)';
    ctx.beginPath();
    ctx.moveTo(x+6*DPR, 0); ctx.lineTo(x+6*DPR, gapTop - CONFIG.pipeLip*DPR); // top left line
    ctx.moveTo(x+6*DPR, gapBot + CONFIG.pipeLip*DPR); ctx.lineTo(x+6*DPR, view.h*DPR); // bottom left
    ctx.stroke();
  }
  aabbs(){
    // returns two AABBs (top, bottom)
    const x=this.x, w=CONFIG.pipeWidth;
    const topH = (this.gapY - this.gap/2) - CONFIG.pipeLip;
    const botY = (this.gapY + this.gap/2) + CONFIG.pipeLip;
    return [
      { x, y: -1000, w, h: Math.max(0, topH+1000) },
      { x, y: botY, w, h: (view.h - botY) + 1000 },
    ];
  }
}
const pipes = new Pool(PipePair, 20);

/* ===============================
   BACKGROUND (parallax)
   =============================== */
const Bg = {
  t:0,
  draw(ctx, dt, speed) {
    this.t += dt;

    // Sky gradient
    const sky = ctx.createLinearGradient(0,0,0,view.h*DPR);
    sky.addColorStop(0,'#0d1530');
    sky.addColorStop(1,'#1a2a55');
    ctx.fillStyle = sky;
    ctx.fillRect(0,0, view.w*DPR, view.h*DPR);

    // Stars
    ctx.fillStyle='rgba(255,255,255,.8)';
    const starCount = Math.floor(view.w*view.h/10000);
    for (let i=0;i<starCount;i++){
      const x=((i*97)%view.w + (this.t*10))%view.w;
      const y=(i*53)%view.h;
      ctx.globalAlpha = .5 + .5*Math.sin(this.t*2 + i);
      ctx.fillRect(Math.floor(x*DPR), Math.floor(y*DPR), 2,2);
    }
    ctx.globalAlpha=1;

    // Mountains layers
    const baseSpeed = speed*0.2;
    this.drawHills(ctx, '#182b48', 160, baseSpeed*0.32);
    this.drawHills(ctx, '#213b68', 220, baseSpeed*0.56);
    this.drawHills(ctx, '#2b4b82', 300, baseSpeed*0.82);

    // Ground strip
    ctx.fillStyle='#1d2d4f';
    ctx.fillRect(0, (view.h-28)*DPR, view.w*DPR, 28*DPR);
  },
  drawHills(ctx, color, height, spd){
    ctx.fillStyle=color;
    const yBase = view.h - 28;
    const w = view.w*DPR, h = view.h*DPR;
    ctx.beginPath();
    const off = (this.t*spd) % view.w;
    const step = 160;
    ctx.moveTo(-10, h);
    for (let x=-view.w; x<=view.w*2; x+=step){
      const px = x - off;
      const y = (yBase - height*0.4) + Math.sin((x+100)*0.012)*height*0.25 + Math.cos((x)*0.004)*height*0.15;
      ctx.lineTo(px*DPR, y*DPR);
    }
    ctx.lineTo(w+10, h);
    ctx.closePath();
    ctx.fill();
  }
};

/* ===============================
   COLLISION — AABB + circle refine
   =============================== */
function aabbIntersect(a, b){
  return (a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y);
}
function circleVsAABB(cx,cy,r, box){
  const nx = clamp(cx, box.x, box.x+box.w);
  const ny = clamp(cy, box.y, box.y+box.h);
  const dx = cx - nx, dy = cy - ny;
  return (dx*dx + dy*dy) < r*r;
}
function birdHitsPipe(bird, pair){
  const aabb = bird.aabb();
  const boxes = pair.aabbs();
  // First coarse: AABB vs both
  for (let b of boxes){
    if (aabbIntersect(aabb,b)) {
      // refine with circle (feels fair)
      if (circleVsAABB(bird.x, bird.y, CONFIG.birdRadius, b)) return true;
    }
  }
  // Floor/ceiling
  if (aabb.y < -10 || aabb.y + aabb.h > view.h-28) return true;
  return false;
}

/* ===============================
   PIPE GENERATOR — Feasible sequences
   =============================== */
let lastGapY = view.h*0.5;
function nextGapY(gapSize){
  const margin = CONFIG.safeMargin;
  const minY = margin + gapSize/2;
  const maxY = (view.h - margin) - gapSize/2;

  // Limit vertical shift between consecutive pipes to ensure feasibility
  const target = clamp(lastGapY + rand(-CONFIG.maxGapDeltaPerPipe, CONFIG.maxGapDeltaPerPipe), minY, maxY);

  // Slight ease toward center to avoid edge clustering
  const eased = clamp(lerp(target, view.h*0.5, 0.1), minY, maxY);
  lastGapY = eased;
  return eased;
}

/* ===============================
   SCORE & UI
   =============================== */
function setScore(n, pop=false){
  State.score = n;
  scoreEl.textContent = n;
  if (pop) {
    scoreEl.style.transform = `scale(${CONFIG.scorePopScale})`;
    setTimeout(()=>scoreEl.style.transform='scale(1)', CONFIG.scorePopTime);
  }
  subhudEl.textContent = `Best: ${State.best}`;
}
function showToast(msg, ms=1400){
  toastEl.textContent = msg; toastEl.style.display='block'; toastEl.classList.add('fade');
  setTimeout(()=>{ toastEl.style.display='none'; toastEl.classList.remove('fade'); }, ms);
}

/* ===============================
   UI SCREENS
   =============================== */
function clearOverlay(){ overlay.innerHTML=''; }

function showTitle() {
  clearOverlay();
  const panel = document.createElement('div');
  panel.className='panel fade';
  panel.innerHTML = `
    <div class="title">Sky Flap</div>
    <div>Flap through the pipes. Simple. Polished. Fair.</div>
    <div class="small" style="margin-top:6px">Controls:
      <span class="key">Space</span> <span class="key">↑</span> <span class="key">Click</span> <span class="key">Tap</span> to flap
      · <span class="key">P</span> pause · <span class="key">M</span> mute
    </div>
    <div class="row">
      <div class="btn" id="btnStart" role="button" aria-label="Start">Start</div>
      <div class="btn" id="btnShare" role="button" aria-label="Share">Share</div>
    </div>
  `;
  overlay.appendChild(panel);
  overlay.style.pointerEvents='auto';

  document.getElementById('btnStart').onclick = ()=>{
    overlay.style.pointerEvents='none';
    fadeOutOverlay(()=> startGame() );
  };
  document.getElementById('btnShare').onclick = ()=>{
    navigator.clipboard?.writeText('Playing Sky Flap! 🐦✨')
      .then(()=>showToast('Copied a share message!'))
      .catch(()=>showToast('Copy not supported here'));
  };
}
function showPause() {
  clearOverlay();
  const panel = document.createElement('div');
  panel.className='panel fade';
  panel.innerHTML = `<div class="title">Paused</div>
    <div class="row">
      <div class="btn" id="btnResume">Resume</div>
      <div class="btn" id="btnRestart">Restart</div>
    </div>`;
  overlay.appendChild(panel);
  overlay.style.pointerEvents='auto';
  document.getElementById('btnResume').onclick = ()=>{ togglePause(false); };
  document.getElementById('btnRestart').onclick = ()=>{ fadeOutOverlay(()=> startGame()); };
}
function showGameOver() {
  clearOverlay();
  const panel = document.createElement('div');
  panel.className='panel fade';
  panel.innerHTML = `
    <div class="title">Game Over</div>
    <div style="margin:.2rem 0 .6rem 0">
      Score: <b>${State.score}</b> · Best: <b>${State.best}</b>
    </div>
    <div class="row">
      <div class="btn" id="btnAgain">Restart</div>
      <div class="btn" id="btnShare2">Share</div>
    </div>
  `;
  overlay.appendChild(panel);
  overlay.style.pointerEvents='auto';
  document.getElementById('btnAgain').onclick = ()=>{ overlay.style.pointerEvents='none'; fadeOutOverlay(()=> startGame()); };
  document.getElementById('btnShare2').onclick = ()=>{
    navigator.clipboard?.writeText(`I scored ${State.score} in Sky Flap! Can you beat me? 🐦`)
      .then(()=>showToast('Copied result text!'))
      .catch(()=>showToast('Copy not supported here'));
  };
}
function fadeOutOverlay(cb){
  const el = overlay.firstElementChild;
  if (!el) return cb&&cb();
  el.style.animation = `fade .${Math.floor(CONFIG.fadeTime)}s ease reverse both`;
  setTimeout(()=>{ clearOverlay(); cb&&cb(); }, CONFIG.fadeTime);
}

/* ===============================
   GAME CONTROL
   =============================== */
let lastTs = performance.now();
let accum = 0;

function resetWorld() {
  // reset pools
  pipes.pool.forEach(p=>{p.active=false;});
  particles.pool.forEach(p=>{p.active=false;});
  Bird.reset();
  State.time=0; State.score=0; setScore(0,false);
  State.scroll=CONFIG.pipeSpeed; State.gap=CONFIG.initialGap; State.difficultySteps=0;
  State.lastSpawn=0; lastGapY = view.h*0.5;
  State.effectsReduced=false;
}

function startGame() {
  resetWorld();
  State.mode='play';
  Audio.playBgm(false); // Keep BGM off by default; toggle with M if you want
  showToast('Go!');
}

function togglePause(forceState){
  if (State.mode!=='play' && State.mode!=='paused') return;
  if (forceState===false || (forceState===undefined && State.mode==='play')) {
    State.mode='paused'; showPause();
  } else {
    State.mode='play'; overlay.innerHTML=''; overlay.style.pointerEvents='none';
  }
}

function endGame() {
  State.mode='gameover';
  Audio.beep(CONFIG.sfx.hit);
  if (State.score>State.best) {
    State.best=State.score; localStorage.setItem(LS_KEY, String(State.best)); subhudEl.textContent=`Best: ${State.best}`;
    showToast('New Best!');
  }
  showGameOver();
}

/* ===============================
   MAIN LOOP
   =============================== */
function loop(ts) {
  const dt = Math.min(0.04, (ts - lastTs)/1000 * (1/DPR)); // tie dt loosely to logical pixels
  lastTs = ts;
  if (State.mode==='play') update(dt);
  draw(dt);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ===============================
   UPDATE
   =============================== */
let scoreGate = null;
function update(dt) {
  // FPS watchdog
  State.fps = lerp(State.fps, 1/dt, 0.05);
  const low = State.fps < CONFIG.fpsDropDisableEffectsBelow;
  State.effectsReduced = low;

  State.time += dt;

  if (Input.consumePause()) togglePause();

  // Flap handling
  if (Input.consumeFlap()) {
    if (Bird.alive) Bird.flap();
  }

  Bird.step(dt);

  // Spawn pipes
  State.lastSpawn += dt;
  const spawnEvery = CONFIG.spawnInterval;
  if (State.lastSpawn >= spawnEvery){
    State.lastSpawn = 0;
    const gY = nextGapY(State.gap);
    pipes.get().init(view.w+40, gY, State.gap, State.scroll);
    // Establish a score gate at the pipe centerline
    scoreGate = { x: (view.w+40) + CONFIG.pipeWidth/2, awarded:false };
  }

  // Move & collide
  let dead = false;
  pipes.forEachActive(p=>{
    p.step(dt);
    if (!p.passed && Bird.x > p.x + CONFIG.pipeWidth) {
      p.passed = true;
      setScore(State.score+1, true);
      Audio.beep(CONFIG.sfx.score);
      // Difficulty step
      if (State.score % CONFIG.gapDecreaseEvery === 0) {
        State.difficultySteps++;
        State.gap = Math.max(CONFIG.minGap, State.gap - CONFIG.gapDecreaseStep);
        State.scroll = Math.min(CONFIG.speedCap, State.scroll + CONFIG.speedIncreaseStep);
      }
    }
    if (!dead && birdHitsPipe(Bird, p)) dead = true;
  });

  if (dead) {
    Bird.alive=false;
    endGame();
  }
}

/* ===============================
   DRAW
   =============================== */
function draw(dt) {
  ctx.save();
  ctx.scale(1/DPR, 1/DPR); // draw in logical pixels, upscale via DPR in math above

  Bg.draw(ctx, dt, State.scroll);

  // Pipes
  pipes.forEachActive(p=>p.draw(ctx));

  // Bird
  Bird.draw(ctx);

  // Particles
  if (CONFIG.enableParticles && !State.effectsReduced) {
    particles.forEachActive(p=>{ p.step(dt); p.draw(ctx); });
  }

  ctx.restore();
}

/* ===============================
   MUTE BUTTON
   =============================== */
muteBtn.addEventListener('click', ()=>Audio.toggleMute());

/* ===============================
   BOOT: Title screen
   =============================== */
setScore(0,false); subhudEl.textContent = `Best: ${State.best}`;
showTitle();

/* ===============================
   SELF-TESTS (minimal unit tests)
   =============================== */
const SELFTEST = {
  // Physics sanity: flap should give negative vy; gravity pulls positive; cap at terminal
  physics() {
    const b = { vy:0 };
    const g = CONFIG.gravity, flap = CONFIG.flapForce, term = CONFIG.terminalVelocity;
    // Flap impulse
    b.vy = -flap;
    if (!(b.vy<0)) throw new Error('Flap did not give upward velocity');
    // Apply gravity for 5s (should cap at terminal)
    let vy=b.vy, dt=0.016;
    for (let t=0;t<5;t+=dt){
      vy += g*dt; vy = clamp(vy, -flap*1.4, term);
    }
    if (Math.abs(vy-term) > 1) throw new Error('Terminal velocity not respected');
    return 'physics ok';
  },
  // Generator feasibility: simulate a "capability corridor" over N pipes
  generator(N=12) {
    let gap = CONFIG.initialGap;
    let prevY = view.h*0.5;
    let ok = true;
    for (let i=0;i<N;i++){
      const gY = nextGapY(gap);
      const delta = Math.abs(gY - prevY);
      if (delta > CONFIG.maxGapDeltaPerPipe+1) ok=false;
      gap = Math.max(CONFIG.minGap, gap - CONFIG.gapDecreaseStep*( (i>0 && i%CONFIG.gapDecreaseEvery===0)?1:0 ));
      prevY = gY;
    }
    if (!ok) throw new Error('Generator produced excessive gap delta');
    return 'generator ok';
  },
  runAll(){ console.time('SELFTEST'); const r1=this.physics(); const r2=this.generator(14); console.timeEnd('SELFTEST'); return [r1,r2]; }
};
window.SELFTEST = SELFTEST;

/* ===============================
   TUNING TABLE (recommended)
   =============================== */
/*
Parameter            Default   Rationale
-------------------  --------  -----------------------------------------------------------
gravity              2200      Snappy falls; combined with flapForce gives readable arcs.
flapForce            560       One tap lifts ~75–95 px; allows microtaps for precision.
terminalVelocity     820       Prevents uncontrollable dives; keeps difficulty fair.
maxRotation          52°       Visual feedback without over-tilting; avoids sprite clipping.
rotationSpeed        520°/s    Bird reacts fast but not jittery; eases with velocity.
initialGap           210 px    Forgiving start; readable rhythm for first 3–5 pipes.
gapDecreaseEvery     5 pts     Difficulty grows at a human pace (~15–25s for step).
gapDecreaseStep      10 px     Subtle shrink; prevents sudden spike.
minGap               150 px    Lower than this starts feeling unfair for casual play.
pipeSpeed            240 px/s  Comfortable reaction time on desktop/mobile.
speedIncreaseStep    12 px/s   Tightens timing gradually without overwhelming.
speedCap             380 px/s  Upper bound where expert runs still feel conquerable.
spawnInterval        1.4 s     Keeps ~1.4 pipe spacing at base speed (readable).
maxGapDeltaPerPipe   180 px    Ensures feasible vertical transitions between gaps.
birdRadius           22 px     Circle refine makes collisions fair; no hidden pixels.
*/

/* ===============================
   PLAYTESTING CHECKLIST (5 steps)
   =============================== */
/*
1) First Minute: Reach 5+ points consistently (confirm early game is forgiving).
2) Mid Ramp: At ~10 points, ensure gap reduction + speed-up are noticeable but fair.
3) Collision Fairness: Brush pipes with wing and confirm no unfair deaths (AABB+circle).
4) Input Latency: Tap/click rapidly; verify no input is dropped and reaction < 50 ms.
5) Performance: Run for 5 minutes; watch console (no errors) and confirm ~60 FPS.
*/

/* ===============================
   FINAL TUNED VALUES (quick copy)
   =============================== */
/*
gravity=1900
flapForce=600
initial gapSize=210
gapDecreaseRate=10 (every 5 points)
pipeSpeed=240
spawnInterval=1.4
*/

/* ===============================
   DESIGN DECISIONS
   =============================== */
/*
- Physics: A classic constant-gravity model with capped terminal velocity and instant flap impulse yields predictable arcs; gentle rotation easing makes attitude reflect velocity without jitter.
- Difficulty: We reduce gap size and increase scroll speed on a fixed cadence; a feasibility guard caps vertical gap displacement so sequences are always passable.
- Art: Fully procedural vectors (no images) keep the file standalone and crisp at any DPI; parallax layers add depth without heavy draw cost.
- Fair Collisions: AABB followed by circle-vs-AABB refinement avoids hidden-pixel deaths and feels consistent when grazing pipes.
- Performance: requestAnimationFrame, pools for pipes/particles, low GC pressure, and an FPS watchdog that disables non-essential effects under load ensure 60 FPS on average machines.
*/
</script>
</body>
</html>
